// Copyright Â© 1996-2018, Valve Corporation, All rights reserved.

#include "mem_helpers.h"

#include <malloc.h>
#include <cstring>
#include <limits>

#include "tier0/include/dbg.h"
#include "tier0/include/platform.h"

namespace {
// Generated by Mathematica.
const u8 kRandomBytes[256]{
    95,  126, 220, 71,  92,  179, 95,  219, 111, 150, 38,  155, 181, 62,  40,
    231, 238, 54,  47,  55,  186, 204, 64,  70,  118, 94,  107, 251, 199, 140,
    67,  87,  86,  127, 210, 41,  21,  90,  208, 24,  167, 204, 32,  254, 38,
    51,  9,   11,  38,  33,  188, 104, 0,   75,  119, 24,  122, 203, 24,  164,
    250, 224, 241, 182, 213, 201, 173, 67,  200, 255, 244, 227, 46,  219, 26,
    149, 218, 132, 120, 154, 227, 244, 106, 198, 109, 87,  150, 40,  16,  99,
    169, 193, 100, 156, 78,  171, 246, 47,  84,  119, 10,  52,  207, 171, 230,
    90,  90,  127, 180, 153, 68,  140, 62,  14,  87,  57,  208, 154, 116, 29,
    131, 177, 224, 187, 51,  148, 142, 245, 152, 230, 184, 117, 91,  146, 235,
    153, 35,  104, 187, 177, 215, 131, 17,  49,  211, 244, 60,  152, 103, 248,
    51,  224, 237, 240, 51,  30,  10,  233, 253, 106, 252, 73,  134, 136, 178,
    86,  228, 107, 77,  255, 85,  242, 204, 119, 102, 53,  209, 35,  123, 32,
    252, 210, 43,  12,  136, 167, 155, 210, 71,  254, 178, 172, 3,   230, 93,
    208, 196, 68,  235, 16,  106, 189, 201, 177, 85,  78,  206, 187, 48,  68,
    64,  190, 117, 236, 49,  174, 105, 63,  207, 70,  170, 93,  6,   110, 52,
    111, 169, 92,  247, 86,  10,  174, 207, 240, 104, 209, 81,  177, 123, 189,
    175, 212, 101, 219, 114, 243, 44,  91,  51,  139, 91,  57,  120, 41,  98,
    119};

constexpr u32 kFfEeWordPattern{0xFFEEFFEE};

void InitializeToFeeFee(void *memory, usize size) {
  u32 *mem_as_double_words{static_cast<u32 *>(memory)};
  usize double_words_count{(size >> 2) + 1};
  while (double_words_count > 1) {
    *mem_as_double_words = kFfEeWordPattern;
    ++mem_as_double_words;
    --double_words_count;
  }

  u8 *mem_as_bytes{reinterpret_cast<u8 *>(mem_as_double_words)};
  usize bytes_count{(size & 3) + 1}, byte_offset{0};
  while (bytes_count > 1) {
    *mem_as_bytes =
        (reinterpret_cast<const u8 *>(&kFfEeWordPattern))[byte_offset];
    ++byte_offset;
    --bytes_count;
    ++mem_as_bytes;
  }
}

void InitializeToRandom(void *memory, usize size) {
  static thread_local usize random_value_offset{0};

  u8 *mem_as_bytes{static_cast<u8 *>(memory)};
  for (usize i = 0; i < size; i++) {
    mem_as_bytes[i] = kRandomBytes[random_value_offset & 255];
    ++random_value_offset;
  }
}

void DoApplyMemoryInitializations(void *memory, usize size,
                                  bool *is_memory_initialized) {
#ifndef OS_POSIX
  if (!memory) return;

  // If they passed -noinitmemory on the command line, don't do anything here.
  Assert(*is_memory_initialized);

  // First time we get in here, remember all the settings.
  static bool is_debugging{Plat_IsInDebugSession()};
  static bool has_checked_cmdline{false};
  static bool should_randomize_memory{false};

  if (!has_checked_cmdline) {
    has_checked_cmdline = true;

    // APS
    const ch *command_line{Plat_GetCommandLine()};
    if (command_line) {
      if (strstr(command_line, "-RANDOMIZEMEMORY"))
        should_randomize_memory = true;
      if (strstr(command_line, "-NOINITMEMORY")) *is_memory_initialized = false;
    }
  }

  if (should_randomize_memory) {
    // They asked for it.. randomize all the memory.
    InitializeToRandom(memory, size);
  } else {
    if (is_debugging) {
      // Ok, it's already set to 0xbaadf00d, but we want something that will
      // make floating-point #'s NANs.
      InitializeToFeeFee(memory, size);
    }
#ifndef NDEBUG
    else {
      // Ok, it's already set to 0xcdcdcdcd, but we want something that will
      // make floating-point #'s NANs.
      InitializeToFeeFee(memory, size);
    }
#endif
  }
#endif
}
}  // namespace

void ApplyMemoryInitializations(void *memory, usize size) {
  static bool is_memory_initialized{true};

  if (is_memory_initialized) {
    DoApplyMemoryInitializations(memory, size, &is_memory_initialized);
  }
}

usize CalcHeapUsed() {
#if defined(OS_POSIX)
  return 0;
#else

  usize heap_total_bytes{0};
  i32 heap_status;

  _HEAPINFO heap_info;
  heap_info._pentry = nullptr;

  while ((heap_status = _heapwalk(&heap_info)) == _HEAPOK) {
    heap_total_bytes += heap_info._useflag == _USEDENTRY ? heap_info._size : 0;
  }

  switch (heap_status) {
    case _HEAPEMPTY:
    case _HEAPEND:
      // success
      break;

    default:
      // heap corrupted
      heap_total_bytes = std::numeric_limits<usize>::max();
  }

  return heap_total_bytes;
#endif
}
